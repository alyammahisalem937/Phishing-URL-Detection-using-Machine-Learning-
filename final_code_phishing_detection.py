# -*- coding: utf-8 -*-
"""Final Code Phishing Detection.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1btJOB9uIy3fSG39ievyKudw4z1bJKniu

# Import Section
"""

#install TLD 
!pip install tld
from tld import get_tld, is_tld

from sklearn.ensemble import RandomForestClassifier
from xgboost import XGBClassifier
from sklearn.naive_bayes import GaussianNB
from sklearn.ensemble import AdaBoostClassifier
from sklearn.neighbors import KNeighborsClassifier

import matplotlib.pyplot as plt
from sklearn.metrics import confusion_matrix, classification_report, accuracy_score

import re
from sklearn.model_selection import train_test_split

import numpy as np

import seaborn as sns

from urllib.parse import urlparse

import pandas as pd

dataset = pd.read_csv('/content/drive/MyDrive/1176 Data/malicious_phish.csv')
dataset.head()

"""# Preprocessing"""

#Clean Dataset for Unwanted Values
dataset.dropna(subset=['url'], inplace=True)
dataset.dropna(subset=['type'], inplace=True)
def data_preprocess(dataset):
    assert isinstance(dataset, pd.DataFrame)
    dataset.dropna(inplace=True)
    left_ones = ~dataset.isin([np.nan, np.inf, -np.inf]).any(axis=1)
    return dataset[left_ones].astype(np.float64)

#remove WWW
dataset['url'] = dataset['url'].replace('www.', '', regex=True)

#Assign Values to the Type Accordingly
detection_type= {"Group": {"benign":0,"malware":3,"phishing":1,"defacement":2}}
dataset['Group'] = dataset['type']
dataset = dataset.replace(detection_type)
dataset

"""# Feature Extraction"""

#find if the url belongs to a specific IP Address

def does_have_ip_address(url):
    pattern = (
        r'((0x[0-9a-fA-F]{1,2})\.(0x[0-9a-fA-F]{1,2})\.(0x[0-9a-fA-F]{1,2})\.(0x[0-9a-fA-F]{1,2})/)' 
        r'([0-9]+(?:\.[0-9]+){3}:[0-9]+)|'
        r'(([01]?\d\d?|2[0-4]\d|25[0-5])\.([01]?\d\d?|2[0-4]\d|25[0-5])\.([01]?\d\d?|2[0-4]\d|25[0-5])\.'
        r'([01]?\d\d?|2[0-4]\d|25[0-5]):\d+)/|'  # IPv4 with port
        r'((?:(?:\d|[01]?\d\d|2[0-4]\d|25[0-5])\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d|\d)(?:/\d{1,2})?)'
        r'(([01]?\d\d?|2[0-4]\d|25[0-5])\.([01]?\d\d?|2[0-4]\d|25[0-5])\.([01]?\d\d?|2[0-4]\d|25[0-5])\.'
        r'([01]?\d\d?|2[0-4]\d|25[0-5])/)|'  # IPv4
    )
    find_ = re.search(pattern, url)
    if find_:
        return 1
    else:
        return 0

#find the domain of the URL
def finding_domainName(given_url):
    try:
        value = get_tld(given_url, as_object = True, fail_silently=False,fix_protocol=True)
        name_of_dom= value.parsed_url.netloc
    except :
        name_of_dom= None
    return name_of_dom

#Finds Unusual Urls
def find_unusual_url(given_url):
    urlname = urlparse(given_url).hostname
    urlname = str(urlname)
    find_match = re.search(urlname, given_url)
    if find_match:
        return 1
    else:
        return 0

#It finds if the http is secure or not
def find_if_http_is_secure(given_url):
    is_secure = urlparse(given_url).scheme
    find_match = str(is_secure)
    if find_match=='https':
        return 1
    else:
        return 0

#Count each digit of the url and return the total value
def count_each_digit(given_url):
    value = 0
    for b in given_url:
        if b.isnumeric():
            value = value + 1
    return value

#find if the url used any shortening website
def is_the_url_shortened(given_url):
    find_ = re.search('goo\.gl|shorte\.st|bit\.ly|x\.co|go2l\.ink|tinyurl|ow\.ly|tr\.im|t\.co|is\.gd|cli\.gs|'
                      'short\.to|BudURL\.com|ping\.fm|post\.ly|Just\.as|bkite\.com|snipr\.com|fic\.kr|loopt\.us|'
                      'migre\.me|yfrog\.com|ff\.im|tiny\.cc|twit\.ac|url4\.eu|su\.pr|snipurl\.com|twurl\.nl|'
                      'db\.tt|adf\.ly|qr\.ae|goo\.gl|cur\.lv|bitly\.com|tinyurl\.com|bit\.ly|ow\.ly|ity\.im|'
                      'doiop\.com|kl\.am|short\.ie|wp\.me|om\.ly|to\.ly|rubyurl\.com|bit\.do|t\.co|lnkd\.in|'
                      'q\.gs|po\.st|is\.gd|bc\.vc|twitthis\.com|j\.mp|u\.to|buzurl\.com|u\.bb|cutt\.us|yourls\.org|'
                      'link\.zip\.net|tr\.im'
                      'prettylinkpro\.com|x\.co|scrnch\.me|vzturl\.com|filoops\.info|qr\.net|1url\.com|v\.gd|tweez\.me|'
                      ,
                      given_url)
    if find_:
        return 1
    else:
        return 0

dataset['find_length_of_url'] = dataset['url'].apply(lambda k: len(str(k)))
dataset['is_ip'] = dataset['url'].apply(lambda k: does_have_ip_address(k))
dataset['domain_name']= dataset['url'].apply(lambda k:finding_domainName(k))
dataset['unusual_url'] = dataset['url'].apply(lambda k: find_unusual_url(k))
dataset['is_secure'] = dataset['url'].apply(lambda k: find_if_http_is_secure(k))
dataset['digits']= dataset['url'].apply(lambda k: count_each_digit(k))
dataset['is_short'] = dataset['url'].apply(lambda k: is_the_url_shortened(k))

#for each signs creates a new column to count how many sign it has
alphaneumeric_character = ['@','?','-','=','.','#','%','+','$','!','*',',','//','~','^']
for character in alphaneumeric_character:
    dataset[character] = dataset['url'].apply(lambda i: i.count(character))

dataset.head(5)

dataset

"""# ML Section"""

#Divide Data Set
X = dataset.drop(['url','type','Group','domain_name'],axis=1)
y = dataset['Group']
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=2)

ml_algorithm = [RandomForestClassifier,KNeighborsClassifier,GaussianNB,AdaBoostClassifier,XGBClassifier]

for ml in ml_algorithm:
    
    print('The model is  =>\033[07m {} \033[0m => '.format(ml))
   
    algo = ml()

    algo.fit(X_train, y_train)
    calculation = algo.predict(X_test)
    accuracy_result = accuracy_score(calculation, y_test)
    print()
    print('Accuracy for : {:.2f}%  is'.format(accuracy_result*100))
    print()
    #print('Here it is the Classification Report')
    print(chr(0x1D) + 'Classification Report'.center(80) + chr(0x1D))
    print(classification_report(y_test, calculation))
    print(chr(0x1D) + 'Confusion Matrix'.center(80) + chr(0x1D))
    
    confusion_mat = confusion_matrix(y_test, calculation)
    plot_ = sns.heatmap(confusion_mat/np.sum(confusion_mat), annot=True,fmt= '0.2%')
    plt.show()

"""# Real Time URL Checking"""

# Take input from the user
url = input("Provide a URL ")

# create a dictionary of data
test_data = {'urls': [url]}

# loop through the list and replace 'www.' with an empty string
for b in range(len(test_data['urls'])):
    test_data['urls'][b] = test_data['urls'][b].replace('www.', '')

# convert the dictionary to a dataframe
df = pd.DataFrame(test_data)

#Finds Unusual Urls
def find_unusual_url(given_url):
    urlname = urlparse(given_url).hostname
    urlname = str(urlname)
    find_match = re.search(urlname, given_url)
    if find_match:
        return 1
    else:
        return 0

#It finds if the http is secure or not
def find_if_http_is_secure(given_url):
    is_secure = urlparse(given_url).scheme
    find_match = str(is_secure)
    if find_match=='https':
        return 1
    else:
        return 0

#Count each digit of the url and return the total value
def count_each_digit(given_url):
    value = 0
    for b in given_url:
        if b.isnumeric():
            value = value + 1
    return value

#find if the url used any shortening website
def is_the_url_shortened(given_url):
    find_match = re.search('goo\.gl|shorte\.st|bit\.ly|x\.co|go2l\.ink|tinyurl|ow\.ly|tr\.im|t\.co|is\.gd|cli\.gs|'
                      'short\.to|BudURL\.com|ping\.fm|post\.ly|Just\.as|bkite\.com|snipr\.com|fic\.kr|loopt\.us|'
                      'migre\.me|yfrog\.com|ff\.im|tiny\.cc|twit\.ac|url4\.eu|su\.pr|snipurl\.com|twurl\.nl|'
                      'db\.tt|adf\.ly|qr\.ae|goo\.gl|cur\.lv|bitly\.com|tinyurl\.com|bit\.ly|ow\.ly|ity\.im|'
                      'doiop\.com|kl\.am|short\.ie|wp\.me|om\.ly|to\.ly|rubyurl\.com|bit\.do|t\.co|lnkd\.in|'
                      'q\.gs|po\.st|is\.gd|bc\.vc|twitthis\.com|j\.mp|u\.to|buzurl\.com|u\.bb|cutt\.us|yourls\.org|'
                      'link\.zip\.net|tr\.im'
                      'prettylinkpro\.com|x\.co|scrnch\.me|vzturl\.com|filoops\.info|qr\.net|1url\.com|v\.gd|tweez\.me|'
                      ,
                      given_url)
    if find_match:
        return 1
    else:
        return 0

#find if the url belongs to a specific IP Address

def does_have_ip_address(url):
    pattern = (
       r'((0x[0-9a-fA-F]{1,2})\.(0x[0-9a-fA-F]{1,2})\.(0x[0-9a-fA-F]{1,2})\.(0x[0-9a-fA-F]{1,2})/)' 
       r'([0-9]+(?:\.[0-9]+){3}:[0-9]+)|'
       r'(([01]?\d\d?|2[0-4]\d|25[0-5])\.([01]?\d\d?|2[0-4]\d|25[0-5])\.([01]?\d\d?|2[0-4]\d|25[0-5])\.'
       r'([01]?\d\d?|2[0-4]\d|25[0-5]):\d+)/|'  # IPv4 with port
       r'((?:(?:\d|[01]?\d\d|2[0-4]\d|25[0-5])\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d|\d)(?:/\d{1,2})?)'
       r'(([01]?\d\d?|2[0-4]\d|25[0-5])\.([01]?\d\d?|2[0-4]\d|25[0-5])\.([01]?\d\d?|2[0-4]\d|25[0-5])\.'
       r'([01]?\d\d?|2[0-4]\d|25[0-5])/)|'  # IPv4
    )
    find_match = re.search(pattern, url)
    if find_match:
        return 1
    else:
        return 0

# apply the len() function to the 'urls' column
df['find_length_of_url']= df['urls'].apply(lambda x: len(str(x)))
df['is_ip'] = df['urls'].apply(lambda x: does_have_ip_address(x))
df['unusual_url'] = df['urls'].apply(lambda x: find_unusual_url(x))
df['is_secure'] = df['urls'].apply(lambda x: find_if_http_is_secure(x))
df['digits']= df['urls'].apply(lambda x: count_each_digit(x))
df['is_short'] = df['urls'].apply(lambda x: is_the_url_shortened(x))



#for each signs creates a new column to count how many sign it has
sign = ['@','?','-','=','.','#','%','+','$','!','*',',','//','~','^']
for b in sign:
    df[b] = df['urls'].apply(lambda x: x.count(b))

test_url = df.drop(['urls'],axis=1)#,'type_code'
test_url

algo = [RandomForestClassifier,KNeighborsClassifier,GaussianNB,AdaBoostClassifier,XGBClassifier]

for a in algo:
    
    print('The model is  =>\033[07m {} \033[0m'.format(a))
    #initializes the model
    model_all = a()
    model_all.fit(X_train, y_train)
    prediction = model_all.predict(test_url)
    if prediction == 0:
      print("It is Benign")
    elif prediction == 1:
      print("It is Phishing")
    elif prediction == 2:
      print("It is Defacement")
    elif prediction == 3:
      print("It is Malware")

models = [XGBClassifier]
pred = 1 
for a in models:
    
    print('The result from XGBoost is')
    #initializes the model
    model_xgb = a()
    model_xgb.fit(X_train, y_train)
    prediction = model_xgb.predict(test_url)
    if prediction == 0:
      print("It is Benign")
    elif prediction == 1:
      print("It is Phishing")
    elif prediction == 2:
      print("It is Defacement")
    elif prediction == 3:
      print("It is Malware")

models = [RandomForestClassifier]
pred = 1 
for a in models:
    
    print('The result from Random Forest is')
    #initializes the model
    model_xgb = a()
    model_xgb.fit(X_train, y_train)
    prediction = model_xgb.predict(test_url)
    if prediction == 0:
      print("It is Benign")
    elif prediction == 1:
      print("It is Phishing")
    elif prediction == 2:
      print("It is Defacement")
    elif prediction == 3:
      print("It is Malware")